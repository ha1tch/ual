-- Example: consider() construct
-- Demonstrates status-based error handling with mandatory handling

@data = stack.new(i64)

-- Simple function that may fail
func divide(a i64, b i64) i64 {
    if (b == 0) {
        status:error("division by zero")
        return 0
    }
    return a / b
}

-- Test 1: Basic consider with ok/error
func test_basic() {
    @data {
        push:10
        push:2
        var result i64 = divide(10, 2)
        push:result
    }.consider(
        ok: {
            dot  -- print result
        },
        error |e|: {
            push:0
            dot
        }
    )
}

-- Test 2: Consider with explicit status setting
func test_explicit_status() {
    @data {
        push:42
        
        -- Simulate a condition that sets custom status
        if (1 == 1) {
            status:success
        }
    }.consider(
        success: {
            dot  -- prints 42
        },
        error: {
            push:0 dot
        },
        _: {
            -- default case
            push:-1 dot
        }
    )
}

-- Test 3: Nested considers
func test_nested() {
    @data {
        push:100
        
        @data {
            push:50
            status:inner_ok
        }.consider(
            inner_ok: {
                -- inner succeeded
                push:1
            },
            _: {
                push:0
            }
        )
        
        status:outer_ok
    }.consider(
        outer_ok: {
            dot dot  -- prints inner result and 100
        },
        _: {
            push:-1 dot
        }
    )
}

-- Test 4: Division by zero handling
func test_division_error() {
    @data {
        var result i64 = divide(10, 0)
        push:result
    }.consider(
        ok: {
            dot
        },
        error |msg|: {
            -- Error case: msg contains "division by zero"
            push:999
            dot
        }
    )
}

-- Main
func main() {
    test_basic()
    test_explicit_status()
    test_nested()
    test_division_error()
}

main()
