# The Philosophy of UAL

## Part One: Why Philosophy Matters for Language Design

Most programming languages are designed by engineers solving engineering problems. This is natural and often productive. Yet it means that certain questions never get asked — questions about what programs fundamentally are, about what we assume when we write code, about whether those assumptions are true.

The discourse around language design operates within a narrow frame. We debate type systems and memory models, syntax preferences and paradigm affiliations. We compare performance characteristics and ergonomic tradeoffs. These are real concerns, but they float on a sea of unexamined assumptions inherited from the 1950s through 1970s, which themselves inherited assumptions from mathematics and formal logic that rarely get questioned.

The deepest most language discussion reaches is Church and Turing — the mathematical foundations of computability. Occasionally Frege or Russell surface in discussions of type theory. The implicit metaphysics is almost always Platonic, concerned with timeless mathematical objects and eternal truths, or Aristotelian, built on objects with properties arranged in taxonomies of types. Nobody asks whether those foundations are right. They are simply the water everyone swims in.

Consider what these assumptions produce. We speak of objects that have properties, that persist through time, that enter into relations with other objects. We organise these objects into hierarchies of inheritance, taxonomies of type. We treat computation as primary — the manipulation of values, the transformation of inputs to outputs — and coordination as a problem to be solved later, usually with libraries or frameworks bolted on after the fact.

These choices are not neutral. They embed a particular view of reality, one where static things are fundamental and processes are what happen to things. Where time is incidental, something to be abstracted away. Where the goal is to describe transformations on data, with the messy business of waiting, synchronising, and failing treated as complications to be managed rather than as the essence of what programs do.

Kant, two and a half centuries ago, made an observation that still unsettles: the world of objects, the world of definite things with properties in relations, is not the whole of reality. There is something else — something he called the noumenal — where the rules that govern objects do not apply. Kant thought this realm was inaccessible to us, which may have been his mistake. But the crack he opened in the object-world remains significant. The admission that definite-thing-talk does not exhaust what is real.

This crack matters for language design because programs are not, in fact, primarily about objects. They are about processes. About coordination. About things happening in time, about waiting for what has not yet arrived, about responding to what cannot be predicted. The object-oriented tradition, dominant for decades, tried to force this processual reality into the mould of objects-with-methods. The functional tradition tried to escape time entirely, seeking the purity of mathematical functions that exist outside temporal flow. Neither fully succeeded, because both started from assumptions that do not match what programs actually are.

UAL began from a different place. Not from engineering problems, though it addresses them. Not from existing paradigms, though it learns from them. It began from questions about what is true — about the nature of processes and relations, about how bounded things emerge from unbounded grounds, about what coordination means and why time cannot be abstracted away.

These questions have been asked before, by thinkers with no knowledge of computers, no interest in programming. They were asked because they are questions about reality, and programs, whatever else they are, exist in reality. They run on physical machines, consume actual time, coordinate real processes. A philosophy that is true of reality should be true of programs. A philosophy that is false should fail when embodied in code.

This is what makes programming an unusual domain for philosophical work. Unlike pure philosophy, where arguments can circle indefinitely, programs either work or they don't. The machine is an impartial judge. If your assumptions about what is primary are wrong, the code becomes tangled, the bugs multiply, the system resists comprehension. If your assumptions are right, things fall into place with surprising ease.

UAL is an attempt to embody philosophical commitments in executable form. To test, through the unforgiving medium of code, whether certain ancient insights about process and relation, about the bounded and the boundless, about time and coordination, are actually true. The language is the experiment. Its coherence or incoherence is the result.

The essays that follow will trace the philosophical foundations of UAL — not as historical curiosity, but as living commitments that shape every design decision. They will show how insights from thinkers separated by millennia converge on the same truths, and how those truths manifest in the concrete details of a programming language.

Philosophy matters for language design because languages embed philosophies whether their designers intend it or not. The only question is whether those philosophies are examined or assumed, whether they are true or merely inherited. UAL chooses examination. What it finds is older and stranger than the tradition that dominates our field — and, perhaps, closer to how things actually are.