# ual 1.5 PROPOSAL: Integrated Testing System (Part 2)

This is not part of the ual spec at this time. All documents marked as PROPOSAL are refinements and the version number indicates the proposal it's targeting to be integrated with into the main ual spec in a forthcoming release.

This document extends the ual 1.5 Testing System PROPOSAL, introducing mocks, code coverage analysis, and structured test suites to create a robust, flexible, and explicit testing model in ual.

---

## 8. Mocking System

### 8.1 Background and Motivation

Testing embedded software presents unique challenges, as many components interact directly with hardware peripherals or external systems that may not be available or practical to use during unit testing. Traditional approaches to this problem include:

1. **Manual Dependency Injection**: Replacing real components with test doubles manually.
2. **Global Function Pointer Replacement**: Substituting function pointers for hardware interfaces.
3. **Preprocessor-Based Mocking**: Using conditional compilation to replace real implementations.

These approaches have significant drawbacks, including maintenance overhead, reduced readability, and a disconnect from the core language paradigms. A more integrated approach that aligns with ual's stack-based design philosophy would provide more elegant and maintainable testing capabilities.

### 8.2 Stack-Based Mock System

Building on ual's typed stack system, we propose a mock system that represents mock objects as specialized stacks. This approach has several advantages:

1. **Paradigm Consistency**: Mocks follow the same stack operations and semantics as regular code.
2. **Type Safety**: The type system ensures that mocks are used appropriately.
3. **Explicit Declaration**: Mocks must be explicitly declared, maintaining ual's emphasis on explicitness.
4. **Zero Runtime Overhead**: Mocks are eliminated from production builds.

### 8.3 Mock Stack Declaration

Mocks in ual follow the structured stack declaration model, ensuring they are defined before use:

```lua
-- Create mock stacks with different behavior types
@Stack.new(Mock, Static): alias "mock_adc"
@Stack.new(Mock, Dynamic): alias "mock_sensor"
@Stack.new(Mock, Fail): alias "mock_wifi"
```

Each mock stack can be created with one of three behavior types:

1. **Static**: Returns predetermined values.
2. **Dynamic**: Returns values generated by a function.
3. **Fail**: Simulates failure conditions.

The mock type annotation is processed by the compiler to generate appropriate implementation code. This is similar to how Go's testing package provides `httptest` for mocking HTTP services, but more deeply integrated with the language.

### 8.4 Assigning Behavior to Mocks

Once declared, mock stacks can be configured with specific behaviors:

```lua
-- Static mock: always returns 3.3V
@mock_adc: push(3.3)

-- Dynamic mock: returns a random value each time
@mock_sensor: function(args) 
  -- Calculate a response based on inputs or state
  local value = random_between(20, 100)
  return value
end

-- Failure mock: always returns an error
@mock_wifi: error("Network Unavailable")
```

The implementation leverages ual's macro system to transform these declarations into appropriate runtime behavior:

```lua
macro_define configure_mock(mock_stack, behavior)
  if is_function(behavior) then
    -- For dynamic mocks
    @#{mock_stack}: set_behavior(behavior)
  elseif is_error(behavior) then
    -- For failure mocks
    @#{mock_stack}: set_failure(behavior)
  else
    -- For static mocks
    @#{mock_stack}: set_value(behavior)
  end
end_macro
```

### 8.5 Mock Implementation Details

Under the hood, mock stacks are implemented as specialized stack types that intercept operations:

```lua
function create_mock_stack(type, name)
  local stack = Stack.new(Any)
  stack.mock_type = type
  stack.name = name
  
  -- Override standard operations
  stack.original_push = stack.push
  stack.original_pop = stack.pop
  
  -- Redefine push to record expected values
  stack.push = function(value)
    stack.expected_values = stack.expected_values or {}
    table.insert(stack.expected_values, value)
  end
  
  -- Redefine pop to return mock values
  stack.pop = function()
    if stack.mock_type == "Static" then
      return stack.static_value
    elseif stack.mock_type == "Dynamic" then
      return stack.behavior_function()
    elseif stack.mock_type == "Fail" then
      error(stack.error_message)
    end
  end
  
  return stack
end
```

This implementation demonstrates how ual's stack abstraction can be extended to provide mock functionality that feels natural within the language.

### 8.6 Using Mocks in Tests

Mocks integrate seamlessly into test cases using the standard stack operations:

```lua
function test_adc_reading() {
  -- Configure mock
  @mock_adc: push(3.3)
  
  -- Call function that uses ADC
  local result = read_voltage()
  
  -- Verify result
  @stack: push(result)
  @expect: push(3.3)
  compare_eq()
  if_false fail("ADC reading was not correctly processed")
}

function test_wifi_error_handling() {
  -- Configure mock to fail
  @mock_wifi: error("Network Unavailable")
  
  -- Call function that should handle errors
  local result = attempt_connection()
  
  -- Verify error was handled gracefully
  @stack: push(result.status)
  @expect: push("offline")
  compare_eq()
  if_false fail("WiFi failure was not handled properly")
}
```

### 8.7 Verification of Mock Interactions

Beyond simple value substitution, mocks also support verification that they were called in expected ways:

```lua
function test_sensor_polling() {
  -- Configure mock
  @mock_sensor: function() return 42 end
  
  -- Call function that should poll the sensor 3 times
  poll_sensors(3)
  
  -- Verify the mock was called the expected number of times
  @mock_sensor: verify_call_count(3)
  if_false fail("Sensor was not polled the expected number of times")
}
```

This verification capability is implemented through call tracking within the mock stack:

```lua
stack.pop = function()
  stack.call_count = (stack.call_count or 0) + 1
  stack.call_history = stack.call_history or {}
  
  -- Record this call with timestamp
  table.insert(stack.call_history, {
    time = os.time(),
    args = stack.current_args
  })
  
  -- Return mock value based on type
  if stack.mock_type == "Static" then
    return stack.static_value
  -- ... other types ...
  end
end

stack.verify_call_count = function(expected_count)
  return stack.call_count == expected_count
end
```

## 9. Code Coverage Analysis

### 9.1 Background and Motivation

Code coverage is an essential metric in modern software testing, measuring how much of a codebase is exercised by tests. In embedded systems, comprehensive coverage is particularly critical due to:

1. **Safety Considerations**: Many embedded systems are deployed in safety-critical contexts.
2. **Limited Runtime Debugging**: Once deployed, diagnosing issues in embedded systems can be difficult.
3. **Resource Constraints**: Every line of code consumes valuable resources, so untested code is particularly wasteful.

Traditional coverage tools may add significant overhead or require external processing. ual's stack-based design provides an opportunity to integrate coverage analysis directly into the language with minimal overhead.

### 9.2 Stack-Based Coverage Tracking

The proposed coverage system leverages ual's stack operations to create a natural, integrated coverage tracking mechanism:

```lua
-- Enable coverage tracking in test mode
macro_if TEST_MODE
  @Stack.new(Coverage): alias "coverage"
  enable_coverage_tracking()
macro_endif

function test_with_coverage() {
  -- Register functions to track
  @coverage: push(function1)
  @coverage: push(function2)
  @coverage: push(function3)
  
  -- Run test that should execute these functions
  complex_operation()
  
  -- Check coverage
  @coverage: check_all()
  if_false warn("Not all functions were executed")
}
```

### 9.3 Implementation Details

Coverage tracking is implemented through compiler instrumentation that adds tracking code at function entry points:

```lua
function instrument_for_coverage(func)
  -- Original function is preserved
  local original = func
  
  -- Create instrumented version
  return function(...)
    -- Record execution
    if coverage_stack then
      coverage_stack.mark_executed(original)
    end
    
    -- Call original function
    return original(...)
  end
end
```

When coverage tracking is enabled, the compiler applies this instrumentation to all functions. At runtime, the coverage stack maintains a record of which functions have been executed:

```lua
coverage_stack.mark_executed = function(func)
  coverage_stack.executed = coverage_stack.executed or {}
  coverage_stack.executed[func] = true
end

coverage_stack.check = function(func)
  return coverage_stack.executed and coverage_stack.executed[func]
end

coverage_stack.check_all = function()
  for i = 1, coverage_stack.depth() do
    local func = coverage_stack.pick(i)
    if not coverage_stack.executed or not coverage_stack.executed[func] then
      return false
    end
  end
  return true
end
```

### 9.4 Advanced Coverage Features

Beyond simple function coverage, the system supports more granular coverage tracking:

#### 9.4.1 Branch Coverage

```lua
function test_with_branch_coverage() {
  -- Enable branch coverage for specific function
  @coverage: enable_branch_coverage(conditional_function)
  
  -- Run tests that should exercise different branches
  conditional_function(true)
  conditional_function(false)
  
  -- Verify all branches were covered
  @coverage: check_branch_coverage(conditional_function)
  if_false warn("Not all branches were executed")
}
```

#### 9.4.2 Path Coverage

```lua
function test_complex_path() {
  -- Register path to track
  @coverage: register_path("critical_path", {
    function1,
    function2,
    function3
  })
  
  -- Run test
  complex_operation()
  
  -- Verify path was executed in order
  @coverage: check_path("critical_path")
  if_false warn("Critical path not fully exercised")
}
```

### 9.5 Coverage Reporting

The coverage system includes reporting capabilities to summarize test coverage:

```lua
function generate_coverage_report() {
  @coverage: generate_report("coverage.txt")
}
```

The report includes:
- Functions covered vs. total functions
- Branches covered (if branch coverage is enabled)
- Paths covered (if path coverage is enabled)
- Uncovered functions listed by name

This information can be used to identify areas requiring additional testing.

## 10. Structured Test Suites

### 10.1 Background and Motivation

As projects grow in size and complexity, organizing tests becomes increasingly important. Individual test functions can quickly become unwieldy, making it difficult to:

1. **Group Related Tests**: Tests for the same component should be grouped logically.
2. **Control Execution Order**: Some tests may depend on specific preconditions.
3. **Manage Test Dependencies**: Setup and teardown operations often need to be shared.

Traditional testing frameworks address these concerns through various mechanisms, but often require complex hierarchies or annotations. ual's stack-based approach offers an opportunity to create a more elegant solution that maintains the language's principles of explicitness and minimal overhead.

### 10.2 Stack-Based Test Suites

Building on ual's typed stack system, test suites are represented as specialized stacks that contain test functions and metadata:

```lua
-- Create a new test suite
@Stack.new(Suite): alias "math_suite"

-- Add tests to the suite
@math_suite: push(test_add)
@math_suite: push(test_subtract)
@math_suite: push(test_multiply)

-- Execute all tests in the suite
@math_suite: run()
```

This approach has several advantages:
1. **Explicit Organization**: Tests are explicitly grouped into suites.
2. **Stack-Based Operations**: Suite manipulation uses familiar stack operations.
3. **Composability**: Suites can be combined and nested using stack operations.

### 10.3 Suite Implementation Details

Under the hood, suite stacks are implemented as specialized stacks with additional operations:

```lua
function create_suite_stack(name)
  local stack = Stack.new(Function)  -- Base stack holds function references
  stack.name = name
  stack.before_each = nil
  stack.after_each = nil
  
  -- Add suite-specific operations
  stack.run = function()
    print("Running test suite: " .. stack.name)
    
    local passed = 0
    local failed = 0
    local failures = {}
    
    for i = 1, stack.depth() do
      local test_func = stack.pick(i)
      local success, error_msg = pcall(function()
        -- Run before_each if defined
        if stack.before_each then
          stack.before_each()
        end
        
        -- Run the test
        test_func()
        
        -- Run after_each if defined
        if stack.after_each then
          stack.after_each()
        end
      end)
      
      if success then
        passed = passed + 1
      else
        failed = failed + 1
        table.insert(failures, {
          test = test_func,
          error = error_msg
        })
      end
    end
    
    print(string.format("Results: %d passed, %d failed", passed, failed))
    
    for _, failure in ipairs(failures) do
      print(string.format("  - %s failed: %s", 
                           get_function_name(failure.test), 
                           failure.error))
    end
    
    return passed, failed, failures
  end
  
  stack.before = function(setup_func)
    stack.before_each = setup_func
  end
  
  stack.after = function(teardown_func)
    stack.after_each = teardown_func
  end
  
  return stack
end
```

### 10.4 Suite Features

Test suites support several features to enhance test organization and execution:

#### 10.4.1 Setup and Teardown

```lua
function test_suite_with_setup() {
  @Suite.new("DatabaseTests"): alias "db_suite"
  
  -- Define setup function
  @db_suite: before(function() {
    initialize_test_database()
  })
  
  -- Define teardown function
  @db_suite: after(function() {
    cleanup_test_database()
  })
  
  -- Add tests
  @db_suite: push(test_insert)
  @db_suite: push(test_query)
  @db_suite: push(test_delete)
  
  -- Run suite
  @db_suite: run()
}
```

#### 10.4.2 Nested Suites

```lua
function create_test_hierarchy() {
  -- Create main suite
  @Suite.new("SystemTests"): alias "system_suite"
  
  -- Create sub-suites
  @Suite.new("NetworkTests"): alias "network_suite"
  @Suite.new("StorageTests"): alias "storage_suite"
  
  -- Add tests to sub-suites
  @network_suite: push(test_connection)
  @network_suite: push(test_protocol)
  
  @storage_suite: push(test_read)
  @storage_suite: push(test_write)
  
  -- Add sub-suites to main suite
  @system_suite: push_suite(network_suite)
  @system_suite: push_suite(storage_suite)
  
  -- Run entire hierarchy
  @system_suite: run_all()
}
```

#### 10.4.3 Selective Execution

```lua
function run_specific_tests() {
  @Suite.new("AllTests"): alias "all_tests"
  
  -- Add many tests
  @all_tests: push(test_1)
  @all_tests: push(test_2)
  // ... more tests ...
  @all_tests: push(test_n)
  
  -- Run only specific tests
  @all_tests: run_only({test_2, test_5, test_8})
}
```

### 10.5 Stack-Based Test Filtering

The suite system supports filtering tests based on various criteria, leveraging ual's stack operations:

```lua
function filter_tests_by_tag() {
  @Suite.new("PerformanceTests"): alias "perf_tests"
  
  -- Tag tests
  @perf_tests: push(test_1, {tags = {"fast", "memory"}})
  @perf_tests: push(test_2, {tags = {"slow", "cpu"}})
  @perf_tests: push(test_3, {tags = {"fast", "cpu"}})
  
  -- Create filter stack
  @Stack.new(String): alias "filter"
  @filter: push("fast")
  @filter: push("cpu")
  
  -- Run only tests matching all filters
  @perf_tests: run_filtered(@filter)
}
```

This filtering mechanism is implemented through stack operations that manipulate test metadata:

```lua
suite_stack.run_filtered = function(filter_stack)
  local filtered_tests = {}
  
  -- Find tests matching filters
  for i = 1, suite_stack.depth() do
    local test = suite_stack.pick(i)
    local meta = suite_stack.get_metadata(test)
    
    local matches = true
    for j = 1, filter_stack.depth() do
      local tag = filter_stack.pick(j)
      if not has_tag(meta.tags, tag) then
        matches = false
        break
      end
    end
    
    if matches then
      table.insert(filtered_tests, test)
    end
  end
  
  -- Run filtered tests
  return suite_stack.run_subset(filtered_tests)
end
```

## 11. Integration with the ual Ecosystem

### 11.1 Macro System Integration

The testing extensions leverage ual's macro system for concise test definitions while maintaining the underlying stack-based model:

```lua
macro_define suite(name, tests)
  @Suite.new(#{name}): alias "#{name}_suite"
  
  #{tests}
  
  @#{name}_suite: run()
end_macro

macro_define test(name, body)
  function test_#{name}()
    #{body}
  end
  
  @#{current_suite}: push(test_#{name})
end_macro

-- Usage
suite("Math", {
  test("addition", {
    @stack: push(2) push(3) add
    @expect: push(5)
    compare_eq()
  })
  
  test("subtraction", {
    @stack: push(5) push(3) sub
    @expect: push(2)
    compare_eq()
  })
})
```

### 11.2 XTXT Integration

The testing system integrates with XTXT to support inline test suites:

```
Frame 1:
:code
package Math

function add(a, b) {
    return a + b
}

:test-suite
@Suite.new("MathTests"): alias "math_tests"

function test_add() {
  @stack: push(2) push(3) add
  @expect: push(5)
  compare_eq()
}

@math_tests: push(test_add)
@math_tests: run()
```

This integration allows test suites to be embedded directly in source files while maintaining logical separation through XTXT streams.

### 11.3 Conditional Compilation

The testing system integrates with ual's conditional compilation system to ensure zero overhead in production builds:

```lua
macro_if TEST_MODE
  -- Test infrastructure
  @Stack.new(Coverage): alias "coverage"
  enable_coverage_tracking()
  
  -- Test suites
  @Suite.new("AllTests"): alias "all_tests"
  // ...
macro_else
  -- No-op implementations for production
  function enable_coverage_tracking() end
macro_endif
```

## 12. Comparison with Other Testing Approaches

### 12.1 Go Testing Package

Go's testing package provides a minimalist approach to testing that has influenced aspects of ual's testing system:

```go
// Go
func TestAdd(t *testing.T) {
    got := Add(2, 3)
    want := 5
    if got != want {
        t.Errorf("Add(2, 3) = %d; want %d", got, want)
    }
}
```

**ual's Approach:**
```lua
// ual
function test_add() {
  @stack: push(2) push(3) add
  @expect: push(5)
  compare_eq()
  if_false fail("Addition failed")
}
```

Key similarities:
- Simple function naming convention for test discovery
- Minimal infrastructure required
- Tests reside in the same package as implementation

Key differences:
- ual leverages stack operations for a more natural testing flow
- ual's type system provides stronger guarantees
- ual's conditional compilation provides more explicit control over test inclusion

### 12.2 Rust Testing Framework

Rust's testing framework provides more features but requires more language machinery:

```rust
// Rust
#[test]
fn test_add() {
    assert_eq!(add(2, 3), 5);
}
```

**ual's Approach:**
```lua
// ual
function test_add() {
  @stack: push(2) push(3) add
  @expect: push(5)
  compare_eq()
}
```

Key similarities:
- Tests are integrated into the language itself
- Strong type checking in tests

Key differences:
- ual avoids special annotations, using naming conventions instead
- ual's stack-based approach provides a more direct expression of test logic
- ual's conditional compilation is more explicit than Rust's attribute-based approach

## 13. Future Directions

While this proposal establishes a comprehensive testing framework for ual, several areas warrant further exploration:

### 13.1 Parameterized Testing

Future versions could support more sophisticated parameterized testing:

```lua
@test.params: {
  {input_a = 1, input_b = 2, expected = 3},
  {input_a = -1, input_b = 1, expected = 0},
  {input_a = 0, input_b = 0, expected = 0}
}

@test.run_params: function(param) {
  @stack: push(param.input_a) push(param.input_b) add
  @expect: push(param.expected)
  compare_eq()
}
```

### 13.2 Property-Based Testing

The stack-based approach could be extended to support property-based testing, where assertions about general properties are verified across many randomly generated inputs:

```lua
function test_add_properties() {
  @property: "commutative" verify(function(a, b) {
    @stack: push(a) push(b) add
    @stack2: push(b) push(a) add
    return stack.pop() == stack2.pop()
  })
}
```

### 13.3 Fuzzing Integration

The testing system could be extended to support fuzzing, where random or structured inputs are generated to find edge cases:

```lua
function test_parser_robustness() {
  @fuzz: function(input) {
    @stack: push(input) parse
    return true  -- Test passes if parse doesn't crash
  }
}
```

## 14. Conclusion

This extension of the ual testing system introduces comprehensive support for mocks, code coverage analysis, and structured test suites, creating a robust, flexible, and explicit testing model that aligns with ual's design philosophy.

The stack-based approach provides a natural, integrated testing experience that leverages ual's core strengths:
- **Type Safety**: The type system ensures correct test construction.
- **Explicitness**: Testing constructs are explicit and clear.
- **Zero Runtime Overhead**: Tests are excluded from production builds.
- **Embedded-Friendly**: The testing system respects resource constraints.

With these additions, ual offers a testing framework that feels like a natural extension of the language itself rather than a bolted-on afterthought. The result is a testing experience that encourages thorough testing while maintaining the language's focus on simplicity, efficiency, and explicitness.